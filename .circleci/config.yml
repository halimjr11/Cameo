# Use CircleCI configuration version 2.1 which supports workflows and orbs
version: 2.1  # Config schema version used by CircleCI

# Define reusable executors, commands, and jobs in a single file for clarity
executors: # A map of named execution environments
  android_executor: # Custom executor for Android builds
    docker: # Use a Docker image to run jobs
      - image: cimg/android:2024.04  # Official CircleCI Android image; using a stable, existing tag to avoid manifest errors
    resource_class: large  # Allocate more CPU/RAM for Gradle builds
    environment: # Global environment variables for this executor
      JVM_OPTS: -Xmx2048m  # Increase JVM heap to reduce OOM risk
      GRADLE_OPTS: -Dorg.gradle.daemon=false -Dorg.gradle.parallel=true -Dorg.gradle.configureondemand=true -Dkotlin.compiler.execution.strategy=in-process  # Gradle tuning flags

# Define the actual job that will run our build, tests, and packaging
jobs: # List of jobs runnable in workflows
  build_test_and_package: # Single job to checkout, cache, test, lint, and build APKs
    executor: android_executor  # Use the custom Android executor defined above
    steps: # Ordered steps the job will execute
      - checkout  # Fetch the repository source code into the job workspace

      - run: # Ensure Gradle wrapper is executable (needed on fresh checkouts)
          name: Make Gradle wrapper executable  # Human-friendly step name
          command: chmod +x ./gradlew  # Grant execute permission to gradlew

      - restore_cache: # Speed up builds by restoring Gradle caches from previous runs
          name: Restore Gradle cache  # Human-friendly step name
          keys: # A list of cache keys to attempt to restore
            - v1-gradle-{{ checksum "gradle/wrapper/gradle-wrapper.properties" }}-{{ checksum "settings.gradle.kts" }}-{{ checksum "build.gradle.kts" }}-{{ checksum "gradle/libs.versions.toml" }}  # Primary cache key including significant Gradle files
            - v1-gradle-  # Fallback to any cache with this prefix

      - run: # Pre-download dependencies to warm cache and fail fast on dependency issues
          name: Gradle dependency resolution  # Human-friendly step name
          command: ./gradlew --no-daemon dependencies || true  # Resolve dependencies for all modules; ignore non-zero to avoid failing due to configuration-only tasks

      - save_cache: # Save Gradle caches after dependency resolution
          name: Save Gradle cache  # Human-friendly step name
          key: v1-gradle-{{ checksum "gradle/wrapper/gradle-wrapper.properties" }}-{{ checksum "settings.gradle.kts" }}-{{ checksum "build.gradle.kts" }}-{{ checksum "gradle/libs.versions.toml" }}  # Cache key matching restore step
          paths: # Directories to cache
            - ~/.gradle/caches  # Gradle caches (dependencies, build caches)
            - ~/.gradle/wrapper  # Gradle wrapper distributions

      - run: # Clean previous builds to ensure a reproducible environment
          name: Clean project  # Human-friendly step name
          command: ./gradlew --no-daemon clean  # Remove build outputs

      - run: # Run static analysis and unit tests
          name: Lint and unit tests  # Human-friendly step name
          command: ./gradlew --no-daemon lint testDebugUnitTest  # Execute Android Lint and unit tests for debug variant

      - store_test_results: # Upload JUnit XML test results so CircleCI can display them
          path: app/build/test-results  # Path where Gradle writes unit test results

      - store_artifacts: # Persist lint reports for inspection in the CircleCI UI
          path: app/build/reports  # Directory containing lint and other reports
          destination: reports  # Name to show in artifacts browser

      - run: # Assemble APKs for distribution/testing
          name: Assemble debug and release APKs  # Human-friendly step name
          command: ./gradlew --no-daemon assembleDebug assembleRelease  # Build debug and release APKs

      - store_artifacts: # Upload built debug APK(s) as artifacts for download
          path: app/build/outputs/apk/debug  # Directory containing debug APK outputs
          destination: apk/debug  # Artifact destination folder name

      - store_artifacts: # Upload built release APK(s) as artifacts for download
          path: app/build/outputs/apk/release  # Directory containing release APK outputs
          destination: apk/release  # Artifact destination folder name

      - store_artifacts: # Upload ProGuard/R8 mapping files if present for release builds
          path: app/build/outputs/mapping/release  # Directory containing mapping files
          destination: mapping/release
          
      # Persist the APK files to be used in the next job
      - persist_to_workspace:
          root: .
          paths:
            - app/build/outputs/apk/release/*.apk
            - app/build/outputs/mapping/release/*

  create_release:
    executor: android_executor
    steps:
      - checkout
      - run:
          name: Install dependencies
          command: |
            sudo apt-get update
            sudo apt-get install -y jq curl
            
      # Restore the workspace from the build job
      - attach_workspace:
          at: .
          
      - run:
          name: Verify APK exists
          command: |
            # Create the directory if it doesn't exist
            mkdir -p app/build/outputs/apk/release
            
            # Check if we have any APK files
            APK_COUNT=$(find app/build/outputs/apk/release -name "*.apk" | wc -l)
            
            if [ "$APK_COUNT" -eq 0 ]; then
              echo "‚ùå Error: No APK files found in app/build/outputs/apk/release/"
              echo "Current directory: $(pwd)"
              echo "Directory contents:"
              ls -la app/build/outputs/apk/release/ 2>/dev/null || echo "APK directory not found"
              echo "Workspace contents:"
              find . -name "*.apk" || echo "No APK files found in workspace"
              exit 1
            fi
            
            echo "‚úÖ Found $APK_COUNT APK file(s) for release"

      - run:
          name: Create GitHub Release
          command: |
            # Set repository information
            REPO_OWNER="halimjr11"  # Ganti dengan username GitHub Anda
            REPO_NAME="Cameo"       # Ganti dengan nama repository Anda
            
            # Prepare release data
            RELEASE_TAG="v1.0.0"
            RELEASE_BODY="Automated release created by CircleCI\n\nChanges in this release:\n- Built from branch: ${CIRCLE_BRANCH}\n- Build number: ${CIRCLE_BUILD_NUM}\n- Commit: ${CIRCLE_SHA1}"
            
            # Create release
            echo "Creating release $RELEASE_TAG..."
            RESPONSE=$(curl -s -X POST \
              -H "Authorization: token ${GH_TOKEN}" \
              -H "Accept: application/vnd.github.v3+json" \
              -d "{\"tag_name\":\"$RELEASE_TAG\",\"name\":\"Release $RELEASE_TAG\",\"body\":\"$RELEASE_BODY\",\"draft\":false,\"prerelease\":false}" \
              "https://api.github.com/repos/$REPO_OWNER/$REPO_NAME/releases")
            
            echo "API Response: $RESPONSE"
            
            # Extract release ID
            RELEASE_ID=$(echo "$RESPONSE" | jq -r '.id')
            
            if [ "$RELEASE_ID" == "null" ]; then
              echo "‚ùå Failed to create release"
              echo "Response: $RESPONSE"
              exit 1
            fi
            
            echo "‚úÖ Created release ID: $RELEASE_ID"
            
            # Upload APK files
            for apk in app/build/outputs/apk/release/*.apk; do
              if [ -f "$apk" ]; then
                echo "üì§ Uploading $(basename "$apk")..."
                UPLOAD_URL="https://uploads.github.com/repos/$REPO_OWNER/$REPO_NAME/releases/$RELEASE_ID/assets?name=$(basename "$apk")"
                
                UPLOAD_RESPONSE=$(curl -s -X POST \
                  -H "Authorization: token ${GH_TOKEN}" \
                  -H "Content-Type: $(file -b --mime-type "$apk")" \
                  -H "Accept: application/vnd.github.v3+json" \
                  --data-binary @"$apk" \
                  "$UPLOAD_URL")
                
                if echo "$UPLOAD_RESPONSE" | jq -e '.errors' > /dev/null; then
                  echo "‚ùå Failed to upload $(basename "$apk")"
                  echo "Response: $UPLOAD_RESPONSE"
                else
                  echo "‚úÖ Uploaded $(basename "$apk")"
                fi
              fi
            done

# Define the workflow tying jobs together and setting the run order
workflows:
  ci:
    jobs:
      - build_test_and_package
      - create_release:
          requires:
            - build_test_and_package
          filters:
            branches:
              only: MADE/submission-2
          context: github-release
